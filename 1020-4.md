# v5.0 重构实施计划

## 🎯 目标

最小侵入、可回滚地完成 v5 配置化 + 契约层 + 数字化动作 + 可配置调度（phase_cycle）。不改环境动力学与槽位导入；主要完成装配与数据结构"统一口径"。

## ✅ 结果验收标准（DoD）

- **配置**: `city_config_v5_0.json`（数字化动作）可被加载；支持 phase_cycle 调度
- **契约**: 统一使用 `ActionCandidate` / `Sequence` / `StepLog` 三个数据结构
- **训练/评估**: 主循环仅依赖契约对象与配置，不再散落 if-else
- **导出**: txt 直接输出动作编号；无任何"名称↔编号"映射代码
- **表格/分析**: 仅读取 `StepLog.reward_terms` 与 `chosen`
- **回归**: 用 v4.1 固定种子跑 1 条 golden trace，比对 reward 分项与预算曲线不劣化

## 📋 实施计划

### 阶段1: 契约层实现

#### 1.1 创建契约数据结构
```python
# contracts/contracts.py
from dataclasses import dataclass
from typing import Dict, List, Any
import numpy as np

@dataclass(frozen=True)
class ActionCandidate:
    """统一候选动作的评分对象"""
    id: int                   # 动作编号（0..N-1）
    features: np.ndarray      # 给策略网络打分的特征
    meta: Dict[str, Any]      # 例如 slot_id、agent、合法性标记等

@dataclass(frozen=True)
class Sequence:
    """统一动作序列（每个 agent 在一个阶段内的选择）"""
    agent: str                # "IND" / "EDU" / "COUNCIL"
    actions: List[int]        # 例如 [0,3,5]：全是编号

@dataclass
class StepLog:
    """统一一步日志"""
    t: int
    agent: str
    chosen: List[int]                     # 实际执行的动作编号
    reward_terms: Dict[str, float]        # {"revenue":..., "cost":..., ...}
    budget_snapshot: Dict[str, float] | None = None
```

#### 1.2 创建配置加载器
```python
# config/config_loader.py
class ConfigLoader:
    def load_v5_config(self, path: str) -> Dict[str, Any]:
        """加载v5.0配置并解析路径引用"""
        pass
    
    def resolve_paths(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """解析路径引用，如 ${paths.slots_txt}"""
        pass
    
    def validate_config(self, config: Dict[str, Any]) -> bool:
        """验证配置完整性"""
        pass
```

#### 1.3 创建调度器
```python
# scheduler/phase_cycle_scheduler.py
class PhaseCycleScheduler:
    def get_active_agents(self, step: int) -> List[str]:
        """根据phase_cycle配置获取活跃智能体"""
        pass
    
    def get_execution_mode(self, agents: List[str]) -> str:
        """获取执行模式：concurrent 或 sequential"""
        pass
```

### 阶段2: 配置系统重构

#### 2.1 实现路径引用解析
- 解析 `${paths.slots_txt}` 等引用
- 支持嵌套路径引用
- 验证路径存在性

#### 2.2 实现数字化动作参数
- 加载 `action_params` 配置
- 支持动作ID到参数的映射
- 验证动作参数完整性

#### 2.3 实现phase_cycle调度
- 支持周期性阶段切换
- 支持并发和顺序执行模式
- 支持智能体执行顺序

### 阶段3: 数据结构统一

#### 3.1 重构动作选择逻辑
```python
# 替换原有的动作选择逻辑
def select_actions(agent: str, candidates: List[ActionCandidate]) -> Sequence:
    """基于契约对象选择动作"""
    pass
```

#### 3.2 重构奖励计算
```python
# 统一奖励计算接口
def calculate_rewards(action: Action, state: EnvironmentState) -> Dict[str, float]:
    """计算奖励分项"""
    pass
```

#### 3.3 重构日志记录
```python
# 统一日志记录
def log_step(step_log: StepLog) -> None:
    """记录步骤日志"""
    pass
```

### 阶段4: 训练/评估重构

#### 4.1 重构主训练循环
```python
# 修改主训练循环
def run_episode(config: Dict, scheduler: PhaseCycleScheduler) -> List[StepLog]:
    """基于配置和契约对象运行一个episode"""
    pass
```

#### 4.2 移除散落if-else逻辑
- 使用配置驱动决策
- 基于契约对象交互
- 统一错误处理

#### 4.3 实现数字化动作选择
- 直接使用动作编号
- 移除名称映射代码
- 支持动作参数查询

### 阶段5: 导出系统重构

#### 5.1 重构txt导出
```python
# 基于StepLog导出txt
def export_txt(step_logs: List[StepLog], output_path: str) -> None:
    """直接输出动作编号"""
    pass
```

#### 5.2 重构分析报告
```python
# 基于StepLog生成分析
def generate_analysis(step_logs: List[StepLog]) -> Dict[str, Any]:
    """生成分析报告"""
    pass
```

#### 5.3 移除自定义JSON结构
- 统一使用StepLog
- 移除自定义数据结构
- 简化数据流

### 阶段6: 回归测试

#### 6.1 固定种子测试
```python
# 使用v4.1固定种子
def run_regression_test() -> bool:
    """运行回归测试"""
    pass
```

#### 6.2 奖励分项对比
- 对比reward_terms
- 验证计算逻辑一致性
- 确保数值精度

#### 6.3 预算曲线验证
- 对比预算变化
- 验证预算计算逻辑
- 确保财务一致性

## 🏗️ 文件结构

```
v5_refactor/
├── contracts/
│   ├── __init__.py
│   └── contracts.py          # 核心契约定义
├── config/
│   ├── __init__.py
│   └── config_loader.py      # 配置加载器
├── scheduler/
│   ├── __init__.py
│   └── phase_cycle_scheduler.py  # 调度器
├── core/
│   ├── __init__.py
│   ├── action_selector.py    # 动作选择器
│   ├── reward_calculator.py # 奖励计算器
│   └── logger.py            # 日志记录器
├── training/
│   ├── __init__.py
│   └── episode_runner.py     # 训练循环
├── export/
│   ├── __init__.py
│   ├── txt_exporter.py      # txt导出器
│   └── analysis_generator.py # 分析生成器
└── tests/
    ├── __init__.py
    ├── test_contracts.py     # 契约测试
    ├── test_config.py       # 配置测试
    └── test_regression.py   # 回归测试
```

## 🔧 技术实现细节

### 1. 最小侵入原则
- 保持现有环境动力学不变
- 只修改装配和数据结构
- 确保可回滚

### 2. 契约优先
- 所有模块通过契约交互
- 统一数据格式
- 类型安全

### 3. 配置驱动
- 使用v5.0配置
- 支持动态调度
- 路径引用解析

### 4. 回归验证
- 固定种子测试
- 奖励分项对比
- 预算曲线验证

## 📊 验收标准

### 配置化完成
- [ ] `city_config_v5_0.json` 可被加载
- [ ] 支持 phase_cycle 调度
- [ ] 数字化动作参数生效

### 契约层完成
- [ ] 统一使用 `ActionCandidate`/`Sequence`/`StepLog`
- [ ] 所有模块通过契约交互
- [ ] 类型安全保证

### 训练/评估完成
- [ ] 主循环仅依赖契约对象与配置
- [ ] 移除散落 if-else 逻辑
- [ ] 支持数字化动作选择

### 导出系统完成
- [ ] txt 直接输出动作编号
- [ ] 基于 `StepLog` 生成分析
- [ ] 移除名称映射代码

### 回归测试通过
- [ ] v4.1 固定种子测试
- [ ] 奖励分项对比
- [ ] 预算曲线验证

## 🚀 实施时间线

- **第1周**: 契约层实现 + 配置系统重构
- **第2周**: 数据结构统一 + 训练/评估重构
- **第3周**: 导出系统重构 + 回归测试
- **第4周**: 优化 + 文档 + 部署

## 🎯 成功标准

1. **功能完整性**: 所有v4.1功能在v5.0中正常工作
2. **性能不劣化**: 训练速度和收敛性不降低
3. **代码质量**: 契约清晰、配置驱动、易于维护
4. **回归通过**: 固定种子测试结果一致
5. **文档完整**: 架构文档和API文档齐全
