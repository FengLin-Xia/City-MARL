# 1025-task.md — Add Dynamic Hub & Budget-Unlocked Actions (v5)

> 目标：在**不改契约层与主循环结构**的前提下，实现  
> ① 指定月份激活新 Hub → 影响地价；  
> ② Agent 预算达标后解锁新动作（流水线中间件控制）。

----

## ✅ 成功标准（DoD）

- 配置 `hubs_schedule` 中的 Hub 会在指定 `activation_month` 生效，地价场随之变化（支持 `fade_in_months` 平滑）。
- 新增中间件 `unlock.gate`：当满足 `after_month` + 预算阈值时，动作编号被“解锁”；sticky/dynamic 两种策略生效。
- 产出 `StepLog` 不变；导出 txt 仍为**动作编号**。
- 打开/关闭以上特性，只需改配置，不改代码。

----

## 目录与改动一览

```
config/
  city_config_v5.json                # 配置增量（hub 日程 & 动作解锁）
env/
  land_price_evo.py                  # 小改：按月更新 & Hub 激活（含 fade-in）
action_mw/
  unlock_gate.py                     # 新增：预算解锁中间件
utils/
  event_bus.py                       # 可选：事件总线（便于调试）
docs/feature/
  FEATURE_DYNAMIC_HUB_AND_UNLOCK_ACTIONS.md  # 方案说明（已提供）
```

----

## 0) 预设：契约层 & 控制层不改

- 契约层：`contracts/contracts.py` 维持 `ActionCandidate / Sequence / StepLog`（不增删字段）。
- 控制层：保持“scheduler → pipeline.apply(seq, state) → env.apply(...) → StepLog”的流程；仅确保每步调用一次 `land_price.update_if_needed(t)`。

----

## 1) 配置增量（请合并到 `config/city_config_v5.json`）

### 1.1 Hub 日程（地价演化）
```json
{
  "env": {
    "land_price": {
      "evolution": {
        "enabled": true,
        "recompute_mode": "incremental",
        "cache": true,
        "hubs_schedule": [
          { "id": "Hub_A",  "activation_month": 0,  "x": 120, "y": 340, "sigma_m": 32, "peak": 1.0 },
          { "id": "Hub_B",  "activation_month": 7,  "x": 300, "y": 180, "sigma_m": 28, "peak": 0.9 },
          { "id": "Hub_NEW","activation_month": 18, "x": 420, "y": 260, "sigma_m": 30, "peak": 1.1, "fade_in_months": 3 }
        ]
      }
    }
  }
}
```

### 1.2 动作解锁规则（中间件）
```json
{
  "action_unlocks": {
    "persistence": "sticky",
    "rules": [
      {
        "id": "IND_unlock_stage1",
        "agent": "IND",
        "after_month": 12,
        "budget_threshold": 500,
        "unlock_action_ids": [10, 11]
      },
      {
        "id": "EDU_unlock_stage1",
        "agent": "EDU",
        "after_month": 6,
        "total_budget_threshold": 800,
        "unlock_action_ids": [12]
      }
    ]
  },
  "action_mw": [
    "conflict.drop_late",
    "unlock.gate",
    "budget.shared_ledger",
    "legality.env",
    "sequence.trim_to_max_len"
  ]
}
```

> 同时把被解锁的动作在 `agents.defs.*.action_ids` 与 `action_params` 里**提前声明**（未解锁时由中间件屏蔽）

----

## 2) 环境：地价演化（`env/land_price_evo.py`）

```python
# env/land_price_evo.py
from __future__ import annotations
from typing import Dict, Any, List
import numpy as np

class LandPriceEvo:
    def __init__(self, cfg: Dict[str, Any], grid_shape: tuple[int,int]):
        self.cfg = cfg["env"]["land_price"]
        self.grid_shape = grid_shape
        self.active_hubs: Dict[str, Dict[str, Any]] = {}
        self.cache: Dict[int, np.ndarray] = {}

    def update_if_needed(self, t: int) -> np.ndarray:
        evo = self.cfg.get("evolution", {})
        if not evo.get("enabled", False):
            return self.cache.setdefault(t, self.cache.get(t-1, np.zeros(self.grid_shape, dtype=float)))

        for hub in evo.get("hubs_schedule", []):
            if hub["activation_month"] <= t and hub["id"] not in self.active_hubs:
                self.active_hubs[hub["id"]] = dict(hub) | {"activated_at": t}

        lp_prev = self.cache.get(t-1, np.zeros(self.grid_shape, dtype=float))
        lp = lp_prev.copy()

        for hub_id, h in self.active_hubs.items():
            strength = h.get("peak", 1.0)
            fade = h.get("fade_in_months", 0)
            if fade and t - h["activation_month"] < fade:
                k = (t - h["activation_month"] + 1) / float(fade)
                strength *= max(0.0, min(1.0, k))
            lp += self._gaussian_blob(h["x"], h["y"], h.get("sigma_m", 32), strength)

        self.cache[t] = lp
        return lp

    def _gaussian_blob(self, cx: int, cy: int, sigma_m: float, peak: float) -> np.ndarray:
        H, W = self.grid_shape
        y = np.arange(H)[:, None]; x = np.arange(W)[None, :]
        dist2 = (x - cx) ** 2 + (y - cy) ** 2
        sigma2 = max(1.0, sigma_m) ** 2
        return peak * np.exp(-0.5 * dist2 / sigma2)
```

----

## 3) 中间件：预算解锁（`action_mw/unlock_gate.py`）

```python
# action_mw/unlock_gate.py
from typing import Dict, Any, List, Set
from contracts.contracts import Sequence
from registry import register

@register("action_mw", "unlock.gate")
class UnlockGateMW:
    def __init__(self, params: Dict[str, Any] | None = None):
        self._unlocked: Dict[str, Set[int]] = {}

    def _agent_budget(self, state, agent: str) -> float:
        return state.ledger.balance(agent)

    def _total_budget(self, state) -> float:
        return sum(state.ledger.balance(a) for a in state.agents)

    def apply(self, seq: Sequence, state) -> Sequence:
        cfg = state.cfg.get("action_unlocks", {})
        rules: List[Dict[str, Any]] = cfg.get("rules", [])
        persistence = cfg.get("persistence", "sticky")

        unlocked_now: Set[int] = set()
        candidate_locked: Set[int] = set()
        for r in rules:
            if r.get("agent") != seq.agent:
                continue
            candidate_locked.update(r.get("unlock_action_ids", []))
            if state.t < r.get("after_month", 0):
                continue

            passed = True
            if "budget_threshold" in r:
                passed &= (self._agent_budget(state, seq.agent) >= r["budget_threshold"])
            if "total_budget_threshold" in r:
                passed &= (self._total_budget(state) >= r["total_budget_threshold"])

            if passed:
                unlocked_now.update(r.get("unlock_action_ids", []))

        history = self._unlocked.setdefault(seq.agent, set())
        if persistence == "sticky":
            newly = unlocked_now - history
            if newly and hasattr(state, "events"):
                state.events.emit("ActionUnlocked", {"t": state.t, "agent": seq.agent, "new_actions": list(newly)})
            history |= unlocked_now
            unlocked_effective = history
        else:
            unlocked_effective = unlocked_now

        filtered = [a for a in seq.actions if (a in unlocked_effective) or (a not in candidate_locked)]
        return Sequence(agent=seq.agent, actions=filtered)
```

----

## 4) 事件总线（`utils/event_bus.py`）

```python
class EventBus:
    def __init__(self):
        self._ls = {}
    def subscribe(self, name, fn):
        self._ls.setdefault(name, []).append(fn)
    def emit(self, name, payload):
        for fn in self._ls.get(name, []):
            try: fn(payload)
            except Exception: pass
```

----

## 5) 控制层调用

- 每步地价更新：
  ```python
  lp_grid = land_price_evo.update_if_needed(t)
  state.land_price_grid = lp_grid
  ```
- 流水线确保 `"unlock.gate"` 已启用。

----

## 6) Smoke Test

创建 `scripts/smoke_1025.py`，验证：
- Hub_NEW 在 activation_month 后地价变化。
- budget>=500 时 IND 解锁动作 10/11 并触发事件。

----

## 7) 回滚

关闭功能：
- `land_price.evolution.enabled=false`
- 移除 `"unlock.gate"` 中间件或清空 `rules`。
