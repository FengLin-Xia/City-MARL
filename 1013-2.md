看到了——[validity] {'no_subset': 30} 直接说明：采样时根本没把 subset_indices 写进经验（或键名对不上），导致训练端把所有样本判为无效，于是整轮被跳过→NaN。

先别卡在 subset_indices 上。你当前采样用的是 valid_logits = logits[0, :num_actions]（即“前 K”切片），这意味着根本不需要 subset_indices 也能重放。最快的解法：把 subset_indices 设为可选；如果缺失，就用“前 K”逻辑重建局部分布。

下面给出两处最小改动（直接替换），保证 valid_ratio=1.00 跑起来；之后你再按需补 subset_indices。

1) 训练端：让 subset_indices 变为可选（缺失时用前 K）

文件：trainers/v4_1/ppo_trainer.py（你贴的第 367–408 段和聚合处）：

替换这段重放逻辑（重点看 if subset_ids is None: 分支）：

# —— 重放“局部分布”与“局部索引” —— 
action_idx  = int(exp.get('action_index', -1))
num_actions = exp.get('num_actions', None)
subset_ids  = exp.get('subset_indices', None)  # 可能不存在

# old_logp 也从 exp 读
old_logp = exp.get('old_log_prob', None)

# 统一成张量/基本类型
if isinstance(subset_ids, list):
    subset_ids = torch.tensor(subset_ids, device=self.device, dtype=torch.long)
if old_logp is not None and not torch.is_tensor(old_logp):
    old_logp = torch.tensor([float(old_logp)], device=self.device, dtype=torch.float32)

# —— 有效性判断（subset 可选）——
is_valid = True
if num_actions is None or action_idx < 0 or old_logp is None:
    is_valid = False
else:
    if subset_ids is None:
        # 没有 subset_ids：使用“前K”切片（与采样一致的前K逻辑）
        k = int(num_actions)
        if not (0 <= action_idx < k):
            is_valid = False
        else:
            local_logits = logits[0, :k]
    else:
        # 有 subset_ids：严格按保存顺序切局部 logits
        k = subset_ids.numel()
        if (num_actions is not None) and (k != int(num_actions)):
            is_valid = False
        elif not (0 <= action_idx < k):
            is_valid = False
        else:
            local_logits = logits[0, subset_ids]

if not is_valid:
    log_prob = torch.tensor([float('-inf')], device=self.device)
    entropy  = torch.tensor([0.0], device=self.device)
else:
    dist = torch.distributions.Categorical(logits=local_logits)
    log_prob = dist.log_prob(torch.tensor(action_idx, device=self.device))
    entropy  = dist.entropy()
    if log_prob.dim() == 0: log_prob = log_prob.unsqueeze(0)
    if entropy.dim() == 0:  entropy  = entropy.unsqueeze(0)


聚合 old_log_prob 的判定也要放宽（不要再要求 subset 必须存在）：

old_log_probs_list, valid_flags = [], []
for exp in experiences:
    olp = exp.get('old_log_prob', None)
    aid = exp.get('action_index', -1)
    k   = exp.get('num_actions', None)

    # subset 可缺省
    is_valid = (olp is not None) and (aid is not None) and (int(aid) >= 0) and (k is not None)
    valid_flags.append(is_valid)
    if is_valid:
        if not torch.is_tensor(olp):
            olp = torch.tensor([float(olp)], device=self.device, dtype=torch.float32)
        elif olp.dim() == 0:
            olp = olp.unsqueeze(0)
        elif olp.dim() > 1:
            olp = olp.squeeze()
        old_log_probs_list.append(olp)

valid_mask = torch.tensor(valid_flags, device=self.device, dtype=torch.bool)
if valid_mask.float().mean().item() < 0.5:          # 先放宽阈值，避免全跳过
    print(f"[skip] valid_ratio={valid_mask.float().mean().item():.2f}, skip this mini-batch")
    continue

old_log_probs = torch.stack(old_log_probs_list).to(self.device)


这两处改完，即使 subset_indices 完全没有写入，也能按“前 K”重放，与采样 valid_logits = logits[0, :num_actions] 完全一致，Valid samples 会从 0/30 变为 30/30。

2) 采样端：确保写入 num_actions / action_index / old_log_prob 为CPU 基本类型

文件：enhanced_city_simulation_v4_1.py（经验字典处），确保这三项都在，且是可序列化类型：

experience.update({
    'action_index': int(selected_idx),                  # 局部索引
    'num_actions': int(num_actions),                    # 子集大小
    'old_log_prob': float(old_log_prob.detach().cpu().item()),
    # 'subset_indices': [int(x) for x in subset_indices.detach().cpu().tolist()]  # 可选：暂时不写也行
    # 'state_embed': state_embed.detach().cpu().numpy(),  # 可选：如果你训练端仍重编码，可先不写
})


你现在的有效性统计显示 no_action_index=0 / no_num_actions=0 / no_old_logp=0，说明这三项已经有了；只要训练端放宽 subset 的要求，就能跑。

运行后期望看到的指标

Valid samples: 30/30（或 ≥ 90%）

ratio.mean ≈ 1.0 ± 0.1

clip_fraction ≈ 0.1 ~ 0.3

approx_kl ≈ 0.01 ~ 0.03

entropy 不再固定 ≈ log(K)，会缓慢下降

如果仍然看到 entropy ≈ log(5) 固定、ratio≈6~10、KL>1，那就说明训练端重放用到的还是“整分布/均匀分布”，请再核对：

是否确实走到了 subset_ids is None → local_logits = logits[0, :num_actions] 这条分支；

num_actions 是否 ≤ logits.size(1)；

action_index < num_actions；

logits 是否真的是 actor(state_embed) 的输出（别用到别的张量）。